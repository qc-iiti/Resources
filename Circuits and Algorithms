5. Simulating Quantum Computers
Compared to the advances in theoretical aspects of quantum computing, and even the programming aspects, construction of a reasonably efficient quantum computer still remains elusive.
RSA cryptography was one of the first targets of quantum computing with Shor’s algorithm over thirty years ago, and yet the largest number factorised by a quantum computer is a 48-bit number, and not even using Shor’s algorithm.
So if quantum computers aren’t around, then how do we call what we do quantum computing?
We simply simulate quantum computers and circuits on our classical computers with a variety of techniques, in a process of digital quantum simulation.

The most common ones employed by the familiar tools such as Qiskit and PennyLane are:
Statevector Simulation:- Statevector simply represents the state of a quantum system as a complex vector. This complex vector is what is called the statevector and contains all the information regarding the state of the system. This is the most common and probably the default simulation. Applying a gate to a state involves matrix multiplication between the gate matrix and the statevector.
Tensor Network Simulation:- This is a rather rare digital quantum simulation, similar to statevector simulation, but it makes the process slightly more efficient by representing states in their inherent sparse matrix form, allowing them to handle a larger number of qubits. But due to the constraint of sparsity, they can be difficult to work with for complex entanglement systems or multidimensional systems.
The above are just two examples of what we call digital quantum simulation, i.e., they run on our computers as kind of a virtual machine.

However, there exist more physical simulations of quantum systems, of course called analogue quantum simulators, such as trapped ion configurations and superconducting qubit simulators. They can be very fascinating to research and explore.

A final note on this would be to touch upon the memory used up in digital quantum simulators. As the number of qubits grows, the memory required grows almost exponentially. Hence analogue quantum simulators are being researched in-depth to see how much further they can take us.

6. Measuring a Circuit

What exactly does measuring a circuit entail? I’d like to first point out that it is not exactly similar to how we measure voltage or current in a standard electronic circuit. The concept of ‘measuring’ a quantum circuit is more analogous to a probability experiment where we measure each outcome over repeated trials.
The first step to measuring a circuit is to define the number of shots. You would remember that, earlier while creating the circuit we defined a parameter called ‘shots.’ This shots is the number of times the computer runs the circuit (or number of repetitions in a probability experiment). Each time the computer runs the circuit, the quantum bits collapse into definitive values and the computer tallies that particular value accordingly. 
This is the crucial point of measuring a circuit, it collapses the probabilistic quantum state of a qubit into a definite 0 or 1 state, allowing it to be encoded into a classical bit. Then over the number of shots, we ideally get 0s and 1s as our outcomes in the probabilistic ratio of the quantum bit.
Here’s an example to understand this better. (Code?)
Suppose I build a simple quantum circuit with one wire and 1024 shots, and apply a single Hadamard gate on it. You would remember Hadamard gates from section 3; creating an equal superposition of all possible states, in our real-world case, |0> and |1>.
I now apply a measurement on the wire. This collapses the superposition caused by the Hadamard gate into a single 0 or 1, and the classical bits are increased accordingly. Now, I plot a simple histogram mapping the number of shots of 1 and the number of shots of 0, and ideally the number of shots on each should be 512. This is because of the equal superposition the H gate creates. However, since our world is far from ideal, and our classical computers even more so, we get some error in our measurements. Something like (0: 502, 1: 522).

7. Oracles and their Role in Quantum Circuits
An oracle in Greek mythology was generally a secretive and hidden being who could see into someone’s future. The oracles in quantum circuits are not as cool or secretive but they are equally powerful in the domain of the circuit.
Recall that a Quantum Circuit is a sequence of Quantum Gates. Since all the operations using quantum gates done on qubits are unitary operations (thus, reversible), and thus the Quantum circuit can be written as a product of Unitary quantum gates which is a Unitary matrix (product of unitary matrices is a unitary matrix). Thus, the Quantum Circuit is itself a Unitary Gate and hence reversible. Thus, the Quantum circuits are reversible.
Consider the following operation.
it takes input |x> of some number of qubits and along with the help of a working register (aka garbage register) denoted by (|0>) and produces the output |x>|f (x)> along with some junk bits |junk(x)>. We need to remove the junk since it consumes extra amount of qubits which is a waste of quantum resources and also the junk bits might get entangled with the output and any interference with
environment may lead to decoherence or incorrect output and errors. Thus, we need to remove the junk bits. Using the below circuit it can be seen that the output of the entire circuit is |xi> |f (x)> and the junk bits are now |0> so that they can be used for other purposes in the circuit ahead. In particular, the output from the first quantum circuit Uf is |xi> , |f (x)> , |junk(x)>. To remove the junk bits, we introduce another m qubit ancilla register which helps in copying the output |f (x)> to a temporary register and then
the output from the Uf circuit is passed through its inverse . Thus, upon passing through its inverse the output will be |x> , |0> , |0> since U † is a reverse circuit and hence will make the outputs back to the inputs. Then the bits are swapped between the temporary m-bit register as shown in the figure to get the desired output of |x> , |f (x)> , |0> , |0> with no junk. Thus, the output of the circuit is the input |x> and the output |f (x)>

This leads to the output of |x> and |f(x)> on the two wires and the other two ancilla qubits are uncomputed.
This entire working is called an oracle.

9. Key Techniques & Algorithms
Techniques
Quantum Fourier Transform (QFT): 
The Quantum Fourier Transform (QFT) is the quantum version of the classical Discrete Fourier Transform (DFT), a tool you might encounter in math or signal processing. Its main job is to switch a quantum state from one "language" to another.
From Computational Basis to Fourier Basis: It transforms a state from the familiar computational basis (made of ∣0⟩s and ∣1⟩s) to the Fourier basis. Instead of storing information in the amplitudes (like how much of ∣0⟩ or ∣1⟩ we have), the Fourier basis stores it in the phases of the qubits. 
Imagine you have a sound wave. The computational basis is like looking at the sound's volume at each specific point in time. The Fourier basis is like looking at the different frequencies (the pitches) that make up the sound. The QFT is the tool that lets you switch between these two viewpoints.
Why is it important? 
The QFT is incredibly good at finding periodicities or repeating patterns within a quantum state. This ability to spot cycles is the secret sauce behind many powerful quantum algorithms, most famously Shor's algorithm for factoring large numbers.
Quantum Phase Estimation (QPE): A crucial subroutine that uses the QFT to estimate the eigenvalue of a unitary operator. It's the core component of many other algorithms.
Quantum Addition: Even basic arithmetic is more complex on a quantum computer. A quantum adder circuit takes two quantum registers and calculates their sum into another. Designing these efficiently is essential for building more complex algorithms.
Algorithms
Deutsch-Jozsa Algorithm: Solves a promise problem to determine if a function is constant or balanced. Classically this can take many queries, but the quantum algorithm solves it with just one query by using superposition and phase kickback.
Bernstein-Vazirani (BV) Algorithm: Finds a secret binary string s hidden in an oracle function f(x)=s⋅x(mod2). A classical computer needs n queries for an n-bit string, but the BV algorithm finds it in one query.
Grover's Search Algorithm: Finds a marked item in an unsorted database of size N in roughly O(N​) steps, a quadratic speedup over the classical O(N) approach. It is hugely important for search and optimization problems.
HHL Algorithm: An algorithm for solving linear systems of equations (Ax=b). It can provide an exponential speedup under specific conditions, with applications in machine learning and data analysis.
10. Challenges & The Future of Quantum Algorithms
Developing quantum algorithms is a major challenge.
The Problems: We are in the NISQ (Noisy Intermediate-Scale Quantum) era. Today's quantum computers are small (50-100s of qubits) and highly susceptible to noise and decoherence, where the quantum state is corrupted by its environment. This limits the depth and complexity of circuits we can run reliably.
The Future: The long-term goal is to build fault-tolerant quantum computers. This will require quantum error correction, where many physical qubits are used to encode a single, protected "logical qubit." In the meantime, researchers are focused on:
Developing noise-resilient algorithms for NISQ hardware.
Discovering new quantum algorithms for chemistry, materials science, finance, and machine learning where even a modest quantum computer could provide an advantage.
This guide provides a high-level overview. Each of these topics is a deep field of study, but understanding these core concepts gives you a solid foundation for your journey into quantum computing. Happy exploring!
Hamiltonians
Hamiltonians are math tools that describe the total energy of a quantum system, which helps us understand and control how it behaves. In quantum computing, we use Hamiltonians to design quantum algorithms and solve optimization problems.
While writing the code for quantum algorithms, the Hamiltonian is expressed as a sum of simpler parts, often involving Pauli operators acting on qubits, each multiplied by a coefficient

Using the Hamiltonian to build circuits:
Quantum computers simulate the evolution under this Hamiltonian using quantum gates.The goal is to construct a quantum circuit that approximates the operation  e^iHt, which models how the quantum state changes over time according to the Hamiltonian
You might define the Hamiltonian in Python with a library as a sum of Pauli terms.Then, a function converts this into a quantum circuit that simulates how the quantum system evolves for a set time.This circuit can then be run on a quantum simulator or real quantum hardware, letting you study properties such as energy levels, ground states, or dynamics of the system.Hamiltonian simulation is a fundamental component in several important quantum algorithms and applications in quantum computing. 
key algorithms and areas where Hamiltonians are used:
Quantum chemistry: Simulating molecular energies and properties by modeling the molecular hamiltonian. Algorithms like VQE use hamiltonians to find ground states efficiently, which can be beyond classical capabilities.
materials science: Simulating quantum systems and materials to predict their behavior and design new materials based on their quantum mechanical hamiltonians.
Optimization and Machine Learning: Hamiltonian simulation algorithms are like building blocks inside bigger quantum algorithms used for solving complex problems in optimization and machine learning.

Bell States 
Bell states are a special set of quantum states involving two qubits that are maximally entangled. Entanglement means the qubits become linked such that the measurement of one immediately determines the state of the other, no matter how far apart they are. There are four Bell states, each representing a unique way the two qubits can be related.
Mathematically, they are represented as below
(|00> + |11>)/root 2
(|00> - |11>)/root 2
(|01> + |10>)/root 2
(|01> - |10>)/root 2
Bell states enable teleporting a quantum state from one qubit to another distant qubit without physically sending the qubit itself.They allow sending two classical bits of information by transmitting only one qubit, enhancing communication efficiency.
Algorithms using Bell states:
Quantum Teleportation
Superdense Coding
Quantum Key Distribution 
Entanglement Swapping
Bell Test Experiments

VQE:
The Variational Quantum Eigensolver is a hybrid quantum-classical algorithm used to find the ground state energy of a quantum system, such as molecules in quantum chemistry or spin systems in physics.
Steps to implement VQE:
Express the problem as a Hamiltonian H, which represents the total energy of the quantum system, often derived from a physical or chemical context. 
Map the Hamiltonian into a form suitable for a quantum computer by expressing it as a sum of Pauli operators acting on qubits.
Design a quantum circuit with adjustable parameters that prepares a trial quantum state approximating the ground state of the Hamiltonian. 
Execute the parameterized quantum circuit on quantum hardware or a simulator. Measure expectation values of the Hamiltonian terms to estimate the energy ⟨ψ(θ)∣H∣ψ(θ)⟩.
Use a classical optimization algorithm to update the parameter in the ansatz, aiming to minimize the measured energy.
Repeat the cycle of running the quantum circuit, measuring, and classical optimization until the energy estimate stabilizes at a minimum.
The final energy is an approximation of the ground state energy of the Hamiltonian, and the corresponding parameters describe an approximate ground state quantum state.
